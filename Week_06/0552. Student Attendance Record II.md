### 552. Student Attendance Record II

**Difficulty:** Hard

#### 方法：动态规划

对于每一天，可能的状态有7种：当天是A；当天是L且前一天不是L，没有A；当天是L且前一天不是L，有A；当天是L且前一天是L，没有A；当天是L且前一天是L，有A；当天是P，没有A；当天是P，有A。

状态表示：创建二维数组 `dp`，包含 `n` 行7列，其中 `dp[i][j]` 表示第 `i` 天分别取7种状态下的可奖励的出勤记录的数量，其中 `0 <= i < n`，`0 <= j < 7`。

边界情况：对于第0天，不依赖于前一天，因此 `dp[0][0] = 1`，`dp[0][1] = 1`，`dp[0][5] = 1`，`dp[0]` 中的其余元素都是0。

状态转移方程：考虑可奖励的出勤记录的约束，最多有一个A以及最多有两个连续的L（即不能有三个连续的L）。因此对于第 `i` 天（其中 `i > 0`），每种状态转移如下，此处省略取余操作。

- 当天是A，则之前必须没有A，因此 `dp[i][0] = dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][5])`。

- 当天是L且前一天不是L，没有A，则前一天一定是P且没有A，因此 `dp[i][1] = dp[i - 1][5]`。

- 当天是L且前一天不是L，有A，则前一天可能是A或是P且有A，因此 `dp[i][2] = dp[i - 1][0] + dp[i - 1][6]`。

- 当天是L且前一天是L，没有A，则前一天一定是L且没有A，因此 `dp[i][3] = dp[i - 1][1]`。

- 当天是L且前一天是L，有A，则前一天一定是L且有A，因此 `dp[i][4] = dp[i - 1][2]`。

- 当天是P，没有A，则前一天可以是L（连续一个L或连续两个L都可以）或P且没有A，因此 `dp[i][5] = dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][5]`。

- 当天是P，有A，则前一天可以是A或是L（连续一个L或连续两个L都可以）或P且有A，因此 `dp[i][6] = dp[i - 1][0] + dp[i - 1][2] + dp[i - 1][4] + dp[i - 1][6]`。

遍历结束之后，`dp[n - 1]` 的元素和即为可奖励的出勤记录的数量。

```
class Solution {
    public int checkRecord(int n) {
        final int MODULO = 1000000007;
        long[][] dp = new long[n][7];
        dp[0][0] = 1;
        dp[0][1] = 1;
        dp[0][5] = 1;
        for (int i = 1; i < n; i++) {
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][5]) % MODULO;
            dp[i][1] = dp[i - 1][5];
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][6]) % MODULO;
            dp[i][3] = dp[i - 1][1];
            dp[i][4] = dp[i - 1][2];
            dp[i][5] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][5]) % MODULO;
            dp[i][6] = (dp[i - 1][0] + dp[i - 1][2] + dp[i - 1][4] + dp[i - 1][6]) % MODULO;
        }
        long sum = 0;
        for (int i = 0; i < 7; i++) {
            sum = (sum + dp[n - 1][i]) % MODULO;
        }
        return (int) sum;
    }
}
```

**复杂度分析**

- 时间复杂度：O(n)，其中n是出勤记录的长度。需要对数组 `dp` 中的每个元素的值进行计算。

- 空间复杂度：O(n)，其中n是出勤记录的长度。创建一个二维数组 `dp`，包含n行7列，列数为常数，因此空间复杂度与行数相关。

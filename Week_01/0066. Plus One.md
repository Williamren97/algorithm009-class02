### 66. Plus One

**Difficulty:** Easy

#### 方法：从低位到高位遍历

对一个非负整数加一，根据原始值的不同，可能有以下三种情况。

1. 原始值的个位不等于9。

   - 加一不会产生进位，因此对个位加一即可，不需要更多的操作。

2. 原始值的个位等于9，但是存在不等于9的位。

   - 加一会产生进位，但是不会造成位数增加。

3. 原始值的所有位都等于9。

   - 加一会产生进位，并造成位数增加，且加一之后的数字最高位是1，其余位都是0。

对于三种情况，可以使用通用的方法。

1. 对个位加一，即对数组的最右元素加一。令当前位为个位。

2. 如果当前位不超过9，则结束。

3. 如果当前位超过9，则对更高的一位加一，并将当前位的元素置为零（或者对10取余数），然后将当前位左移一位，直到当前位不超过9或者当前位等于数组的最左的位置。

4. 如果数组的最左的位置的元素超过9，则新建一个数组，最左的位置的元素为1，其余元素都为0，返回新建的数组。

5. 如果数组的最左的位置的元素不超过9，则直接返回数组。

```
class Solution {
    public int[] plusOne(int[] digits) {
        int length = digits.length;
        digits[length - 1]++;
        int index = length - 1;
        while (index > 0 && digits[index] >= 10) {
            digits[index - 1] += digits[index] / 10;
            digits[index] %= 10;
            index--;
        }
        if (digits[0] == 10) {
            int[] sum = new int[length + 1];
            sum[0] = 1;
            return sum;
        } else {
            return digits;
        }
    }
}
```

**复杂度分析**

- 时间复杂度：O(n)，其中n是数组的长度。对数组从右到左一次遍历。

- 空间复杂度：O(1)。返回值不计入空间复杂度。

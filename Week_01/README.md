# 学习笔记

算法题的作业每道题为一个md文件，每道题包含一种或多种解法，每种解法都包含解题思路、代码实现和复杂度分析。

改写Deque代码和分析源码的作业在README的最后。

## 第3课  数组、链表、跳表

### 一、数组

申请数组时，在内存中开辟连续地址。

由于地址连续，可在O(1)时间内查询任何下标的元素。

但是为了维持地址连续的特点，插入和删除元素的时间复杂度较高。

1. 如果在数组末尾插入元素和删除元素，时间复杂度都是O(1)。

2. 如果在数组的其余位置插入元素，则需要首先将从指定位置到末尾的所有元素后移一位，然后在指定位置插入元素，时间复杂度是O(n)，其中n是数组长度。

3. 如果在数组的其余位置删除元素，则在删除元素后，需要将从指定位置后一位到末尾的所有元素前移一位，时间复杂度是O(n)，其中n是数组长度。

具体实现类：ArrayList。

### 二、链表

链表的内存地址不连续，链表中的每个元素是一个节点，每个节点都有相应的值。链表有两种类型。

1. 节点包含指向下一个节点的指针，以这样的节点组成的链表为单向链表。

2. 节点包含指向上一个节点的指针和指向下一个节点的指针，以这样的节点组成的链表为双向链表。

链表中，通常需要指定头节点和尾节点。

在链表中插入和删除元素时，只需要改变相邻节点的指针指向的节点，因此时间复杂度都是O(1)，无论插入和删除的元素是在链表的头部、尾部还是中间。

但是由于链表的内存地址不连续，因此不可像数组那样根据下标直接查询元素，而是需要遍历节点才能查询元素，查询元素的时间复杂度是O(n)，其中n是链表中的元素数量。

具体实现类：LinkedList，为双向链表。

### 三、数组和链表的性能比较

- 数组的查询元素的时间复杂度是O(1)，插入和删除元素的时间复杂度是O(n)。

- 链表的查询元素的时间复杂度是O(n)，插入和删除元素的时间复杂度是O(1)。

基于数组和链表的性能特点，可以得出以下分析。

- 当需要经常查询元素时，使用数组更合适。

- 当需要经常插入和删除元素时，使用链表更合适。

### 四、跳表

跳表的实现基于链表，其目的是降低链表的查询元素的时间复杂度。只适用于元素有序的情况。

跳表对标平衡二叉搜索树和二分查找，插入、删除、查询元素的时间复杂度都是O(log n)，其中n是元素数量。

跳表通过升维的方式进行加速，从一维到二维，包含更多信息。具体实现为在原始链表的基础上增加多级索引，每级索引包含的节点数量依次减少。

跳表的空间复杂度和数组、链表一样是O(n)，但是由于跳表有多级索引，实际使用空间超过数组和链表。

## 第4课  栈、队列、双端队列、优先队列

### 一、栈

Stack：后进先出，添加、删除元素的时间复杂度是O(1)。

由于元素无序，查询的时间复杂度是O(n)，其中n是元素数量。

### 二、队列

Queue：先进先出，添加、删除元素的时间复杂度是O(1)。

由于元素无序，查询的时间复杂度是O(n)，其中n是元素数量。

### 三、双端队列

Deque即Double-Ended Queue：结合了栈和队列的特点，可在头和尾两端添加和删除元素。

双端队列的各项操作的时间复杂度和栈与队列相同，添加、删除元素的时间复杂度是O(1)，查询的时间复杂度是O(n)，其中n是元素数量。

### 四、优先队列

Priority Queue：元素具有优先级顺序，每次取出优先级最高的元素（例如最大值或最小值）。

添加元素的时间复杂度是O(1)，取出元素的时间复杂度是O(log n)，其中n是元素数量。

### 五、API分析

此处只分析Java中的API。

- Stack是具体类，可直接用于实例化对象，但是建议用Deque代替Stack。

- Queue和Deque是接口，需要通过实现类实例化对象，LinkedList是常用的实现类。

- PriorityQueue是Queue的实现类。

### 六、作业

#### 作业1  改写Deque

原始代码：
```
Deque<String> deque = new LinkedList<String>();

deque.push("a");
deque.push("b");
deque.push("c");
System.out.println(deque);

String str = deque.peek();
System.out.println(str);
System.out.println(deque);
while (deque.size() > 0) {
    System.out.println(deque.pop());
}
System.out.println(deque);
```

改写后的代码：

```
Deque<String> deque = new LinkedList<String>();

deque.addFirst("a");
deque.addFirst("b");
deque.addFirst("c");
System.out.println(deque);

String str = deque.peekFirst();
System.out.println(str);
System.out.println(deque);
while (deque.size() > 0) {
    System.out.println(deque.removeFirst());
}
System.out.println(deque);
```

#### 作业2  分析Queue和Priority Queue的源码

##### Queue的源码分析

Queue是一个接口，继承了Collection接口。Queue接口只包含抽象方法。

Queue接口包含以下抽象方法。

1. boolean add(E e);

   - 往队列尾部添加元素，如果添加成功则返回true，如果因为容量限制导致添加失败则抛出IllegalStateException异常。

2. boolean offer(E e);

   - 往队列尾部添加元素，如果添加成功则返回true，如果因为容量限制导致添加失败则返回false。可见在有容量限制的队列中，offer方法由于add方法。

3. E remove();

   - 删除队列头部的元素并返回，如果队列为空则抛出NoSuchElementException。

4. E poll();

   - 删除队列头部的元素并返回，如果队列为空则返回null。

5. E element();

   - 返回队列头部的元素（不从队列删除元素），如果队列为空则抛出NoSuchElementException。

6. E peek();

   - 返回队列头部的元素（不从队列删除元素），如果队列为空则返回null。

##### PriorityQueue的源码分析

PriorityQueue是一个具体类，其底层实现为数组。该类包含的方法较多，此处只分析常用的方法。

1. 添加元素，boolean add(E e)和boolean offer(E e)，当参数e为空时抛出NullPointerException异常，否则执行添加元素，首先判断是否需要扩容，以及在需要扩容的情况下进行扩容，然后将e加到数组末尾，最后对e进行上浮操作以保持优先队列的性质（例如当头部元素最小时，每个元素都比其子节点小）。

2. 查看头部元素，E peek()，如果优先队列为空则返回null，否则返回数组的第一个元素。

3. 移除头部元素并返回，E poll()，如果优先队列为空则返回null，否则将数组的第一个元素作为返回值，将数组的最后一个元素移到数组的第一个元素（原来的最后一个元素变成null），对数组的第一个元素进行下沉操作以保持优先队列的性质（例如当头部元素最小时，每个元素都比其子节点小），最后返回移除的元素。
